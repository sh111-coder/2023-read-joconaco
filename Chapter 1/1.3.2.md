# 1.3.2 💻 코드는 예측가능해야 한다.

## 🎯 1. 실생활 상황 예시
```bash
1. 피자 가게 번호를 찾아서 전화걸기 앱으로 다이얼을 누른다.
2. '라지 사이즈 마르게리타 하나만 배달해주세요!' 배달 주문을 한다.
3. 식당에서 배달 요청을 수락했다.
4. 배달 온 것을 열어보니 '마르게리타 피자' 가 아닌 '마르가리타 칵테일'이 배달되었다.
```
이러한 상황의 원인을 찾기 위해 디버깅(?)을 해봤더니,

전화 걸기 앱에 문제가 있었다.

전화 걸기 앱 개발팀이 통계를 통해 사용자가 식당에 전화를 걸 때 통화중일 경우

80%의 사용자가 즉시 다른 식당에 전화를 건다는 사실을 알게 됐고,

이를 바탕으로 식당에 전화를 걸 때 통화중일 경우 즉시 다른 식당에 전화를 거는 편리한 기능을 추가했다.

사용자는 피자 가게에 전화를 걸어 주문을 했다고 생각했지만

이러한 기능을 통해 멕시코 식당에 주문을 한 것이다.

전화 걸기 앱 개발팀은 좋은 의도로 사용자의 삶을 더 편리하게 만들었다고 생각하겠지만,

사실 그들은 사용자의 예측을 벗어나는 시스템을 만들었다.

우리 두뇌는 어떠한 일을 판단하기 위해 **정신 모델**을 사용한다.

어떤 번호로 전화를 걸 때 연결되었다면, 전화를 건 그 번호와 연결됐다고 생각하는데,

이것은 우리 두뇌 안에 저장된 **‘전화에 대한 정신 모델’** 때문이다.

전화 걸기 앱의 새로운 기능은 전화에 대한 정신 모델과 맞지 않다.

**즉, 사용자가 예측하는 대로 실행이 되지 않는다는 것이다!**

---
## 🎯 2. 코드 예시
위의 예시에서 전화 걸기 앱은 코드와 유사하다.

우리의 코드를 사용하는 다른 개발자는 **이름, 데이터 유형, 일반적인 관행**과 같은 단서를 사용해서

코드가 입력값으로 무엇을 예상하는지, 코드가 무슨일을 하는지, 무엇을 반환하는지에 대한

코드의 **정신 모델**을 구축한다.

우리는 메소드 시그니처(메소드 이름, 매개변수)와 리턴 타입, 일반적인 컨벤션 등을 통해 코드를 예측한다.
```java
* 1. 메소드 이름
public ? add() { ... }
위의 메소드 이름을 보고 '더하는 기능을 하겠구나!' 라고 예측하게 된다.

* 2. 메소드 매개변수
public ? ?(int number1, int number2) { ... }
위의 메소드 매개변수를 보고 'number1, number2라는 수 2개를 받아서 사용하겠구나!' 라고 예측하게 된다.

* 3. 리턴 타입
public int ? ?() { ... }
위의 리턴 타입을 보고 '결과가 int 형으로 나오겠구나!' 라고 예측하게 된다.

* 4. 컨벤션 (네이밍 등)
public ? ? isXxx() { ... }
메소드 이름 네이밍을 보고 'is는 boolean 네이밍 컨벤션이니까 리턴 타입이 boolean이겠구나!' 라고 예측하게 된다.
```
위처럼 코드를 예측하는 여러 요소가 존재하는데, 코드의 **정신 모델이 기대하는 것과 다르게 설계한다면**

위의 실생활 예시처럼 개발자의 예측과 다르게 코드가 동작할 수 있다.

다음과 같은 코드 예시를 들 수 있다.
```java
* 메소드 시그니처 & 리턴 타입으로 코드 예측
public int add(int number1, int number2) { ... }
```

위처럼 메소드 시그니처, 리턴 타입이 있다고 했을 때

개발자는 메소드 내부 코드를 보지 않고도 메소드 시그니처, 리턴 타입만 보고

‘당연히 number1, number2를 더하고, 더한 수를 반환하는 기능이군!’ 하면서 넘어갈 수 있다.

하지만 실제 메소드 내부 코드가 다음과 같이 두 수를 빼는 기능이라면?

개발자의 예측과 다르게 코드가 동작하여 심각한 오류를 발생시킬 수 있을 것이다.

```java
public int add(int number1, int number2) {
    return number1 - number2;
}
```

이 상황에서 잘못한 사람은 메소드 내부 코드를 제대로 보지 않은 ‘다른 개발자’가 아니라,

**코드의 정신 모델과 어긋나는 일(메소드 네이밍과 내부 코드가 불일치함)을 한 ‘코드를 작성한 개발자’이다!**

---
## 🎯 3. 예측 불가능한 코드의 위험성
실생활 예시와 코드 예시 둘 다 ‘예측 불가능한’ 상황때문에 문제가 발생하였다.

하지만, 두 상황 다 기능을 사용할 때 문제가 있음을 인지하지 못하고,

시간이 지나고 나서야 해당 기능에 문제가 있음을 인지하게 되었다.

실생활 예시에서는 배달이 와서 열어보기 전까지는 정상적으로 주문을 한 것으로 인지했고,

코드 예시에서도 수를 더하는 기능이라고 인식하고 넘어갔을 때는 문제가 없었다.

식당에 전화를 해서 ‘마르게리타’를 주문했고, 식당은 기꺼이 응했다.

식당이 ‘마르게리타 칵테일’을 제조하기 전에 문제를 바로잡을 수 없었으며,

배달 음식을 열었을 때 비로소 문제를 깨달았지만 바로잡기에는 너무 늦었다.

이러한 상황은 소프트웨어 시스템에서 일어나는 상황과 유사하다.

코드 예시에서 작업하는 개발자는 add 메소드를 보고 더하는 기능으로 예측 후 작업을 진행한다.

많은 경우에 잠시 동안은 문제가 없는 것처럼 보이기 때문에

프로그램 실행 단계에 가서야 비로소 문제를 인지하고, 바로잡기에는 늦은 시점이 된다.

이처럼 코드가 예상에서 벗어나는 일을 한다면

해당 코드를 사용하는 다른 개발자는 그 상황을 인지하지 못하므로

문제 상황(더하기로 예측했지만 실제는 빼기인 경우)에 대처할 생각조차 하지 못할 것이다.

---
## ✅ 요약
**따라서, 이러한 위험성이 존재하기 때문에 예측 불가능한 코드를 작성하지 않아야 한다.**

**코드는 예측이 가능해야한다!**

3장에서는 예측 가능한 코드를 작성하는 데 도움이 되는 ‘코드 계약에 대한 세심한 주의’를 다룬다.

4장에서는 ‘오류’를 다루는데, 코드에서 이런 오류가 제대로 전달되지 않거나 제대로 처리되지 않으면

해당 오류가 예상을 벗어나는 코드가 될 수 있다.

6장에서는 예측 불가능한 코드 작성을 피하기 위한 구체적인 기술 몇 가지를 살펴본다.
